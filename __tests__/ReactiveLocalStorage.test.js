import { faker } from './helpers'
import { ReactiveLocalStorage } from '../src/reactiveLocalStorage/storage/ReactiveLocalStorage'
import {
  ReactiveLocalStorageError,
  ReactiveStorageError,
} from '../src/reactiveLocalStorage/storage/Error'
import { ref, reactive, isRef, isReactive } from 'vue'

const { localStorage } = window
const filePath = 'src/reactiveLocalStorage/storage/ReactiveLocalStorage.js'

const getDefaultSerializer = () => ({
  serialize: (...parameters) => JSON.stringify(...parameters),
  parse: (...parameters) => JSON.parse(...parameters),
})

const getReactiveLocalStorageInstance = (
  reactiveStorage,
  webStorage,
  serializer,
) => new ReactiveLocalStorage(reactiveStorage, webStorage, serializer)

const createArrayTestWithObjects = (nElement) => {
  const array = []
  for (let i = 0; i < nElement; i++) {
    const element = {
      key: faker.string.sample(),
      value: {
        string: faker.string.sample(),
        number: faker.number.int(),
        array: new Array(faker.number.int({ max: 100 })),
      },
    }
    array.push(element)
  }
  return array
}

const addItemsInReactiveLocalStorage = (elements, reactiveLocalStorage) => {
  elements.forEach((element) => {
    const { key, value } = element
    reactiveLocalStorage.setItem(key, value)
  })
}

describe(`class ReactiveLocalStorage (${filePath})`, () => {
  describe('constructor', () => {
    it('Should create a ReactiveLocalStorage object when the constructor is called using Storage and vue Ref instances', () => {
      // Arrange
      const refStorage = ref({})
      const defaultSerializer = getDefaultSerializer()

      // Act
      const result = () =>
        getReactiveLocalStorageInstance(
          refStorage,
          localStorage,
          defaultSerializer,
        )

      // Assert
      expect(result).not.toThrow()
    })
    it('Should throw a ReactiveLocalStorageError when the constructor is called using vue Ref instance but not a Storage instance', () => {
      // Arrange
      const refStorage = ref({})
      const notStorage = faker.string.sample(100)
      const defaultSerializer = getDefaultSerializer()
      const expected = ReactiveLocalStorageError

      // Act
      const result = () =>
        getReactiveLocalStorageInstance(
          refStorage,
          notStorage,
          defaultSerializer,
        )

      // Assert
      expect(result).toThrow(expected)
    })
    it('Should create a ReactiveLocalStorage object when the constructor is called using Storage and vue Reactive instances', () => {
      // Arrange
      const reactiveStorage = reactive({})
      const defaultSerializer = getDefaultSerializer()

      // Act
      const result = () =>
        getReactiveLocalStorageInstance(
          reactiveStorage,
          localStorage,
          defaultSerializer,
        )

      // Assert
      expect(result).not.toThrow()
    })
    it('Should throw a ReactiveLocalStorageError when the constructor is called using vue Reactive instance but not a Storage instance', () => {
      // Arrange
      const reactiveStorage = reactive({})
      const notStorage = faker.number.int()
      const defaultSerializer = getDefaultSerializer()
      const expected = ReactiveLocalStorageError

      // Act
      const result = () =>
        getReactiveLocalStorageInstance(
          reactiveStorage,
          notStorage,
          defaultSerializer,
        )

      // Assert
      expect(result).toThrow(expected)
    })
    it('Should throw a ReactiveStorageError when the constructor is called using a Storage instance but not a vue Ref/Reactive instance', () => {
      // Arrange
      const notVueReactiveStorage = [1, 2, 3, 4, 5, 6, 7]
      const defaultSerializer = getDefaultSerializer()
      const expected = ReactiveStorageError

      // Act
      const result = () =>
        getReactiveLocalStorageInstance(
          notVueReactiveStorage,
          localStorage,
          defaultSerializer,
        )

      // Assert
      expect(result).toThrow(expected)
    })
  })
  describe('test an instance generated by constructor with parameters (vue Ref, Storage)', () => {
    let reactiveLocalStorage

    beforeEach(() => {
      const refStorage = ref({})
      const defaultSerializer = getDefaultSerializer()
      reactiveLocalStorage = getReactiveLocalStorageInstance(
        refStorage,
        localStorage,
        defaultSerializer,
      )
    })
    afterEach(() => {
      localStorage.clear()
    })

    describe('(getter) length', () => {
      it('Should return 0 when reactiveLocalStorage is empty', () => {
        // Arrange
        const expected = 0

        // Act
        const result = reactiveLocalStorage.length
        const localStorageLength = localStorage.length

        // Assert
        expect(result).toBe(expected)
        expect(localStorageLength).toBe(expected)
      })
      it('Should return 3 when reactiveLocalStorage contain 3 elements', () => {
        // Arrange
        const expected = 3
        const data = createArrayTestWithObjects(expected)
        addItemsInReactiveLocalStorage(data, reactiveLocalStorage)

        // Act
        const result = reactiveLocalStorage.length
        const localStorageLength = localStorage.length

        // Assert
        expect(result).toBe(expected)
        expect(localStorageLength).toBe(expected)
      })
    })
    describe('(getter) reactiveStorage', () => {
      it('Should return the vue ref instance used', () => {
        // Arrange
        const expected = true

        // Act
        const result = isRef(reactiveLocalStorage.reactiveStorage)

        // Assert
        expect(result).toBe(expected)
      })
    })
    describe('(method) key', () => {
      it('Should return null when the key not exists into reactiveLocalStorage', () => {
        // Arrange
        const index = 0

        // Act
        const result = reactiveLocalStorage.key(index)

        // Assert
        expect(result).toBeNull()
      })
      it('Should return the key in fourth position into reactiveLocalStorage', () => {
        // Arrange
        const index = 3
        const nData = 4
        const data = createArrayTestWithObjects(nData)
        const expected = data[index].key
        addItemsInReactiveLocalStorage(data, reactiveLocalStorage)

        // Act
        const result = reactiveLocalStorage.key(index)

        // Assert
        expect(result).toBe(expected)
      })
    })
    describe('(method) setItem', () => {
      it('Should set an object (nested object)', () => {
        // Arrange
        const defaultSerializer = getDefaultSerializer()
        const key = faker.string.sample(30)
        const expected = {
          key1: faker.string.sample(90),
          key2: faker.number.int(),
          key3: {
            nestedObject: {
              key1: faker.string.symbol(17),
              nestedObject: [
                {
                  username: faker.internet.userName(),
                  password: faker.internet.password({ length: 50 }),
                },
                {
                  username: faker.internet.userName(),
                  password: faker.internet.password({ length: 50 }),
                },
                {
                  username: faker.internet.userName(),
                  password: faker.internet.password({ length: 50 }),
                },
              ],
            },
          },
        }

        // Act
        reactiveLocalStorage.setItem(key, expected)

        // Assert
        const result = reactiveLocalStorage.getItem(key)
        const valueReturnedFromLocalStorage = localStorage.getItem(key)
        const unserializedValue = defaultSerializer.parse(
          valueReturnedFromLocalStorage,
        )

        expect(result).toEqual(expected)
        expect(result).toEqual(unserializedValue)
      })
      it('Should override an object saved in reactiveLocalStorage when add a new object using the same key', () => {
        // Arrange
        const defaultSerializer = getDefaultSerializer()
        const key = faker.string.sample(50)
        const initValue = {
          user: faker.internet.userName(),
          password: faker.internet.password({ length: 17 }),
        }
        const expected = {
          ...initValue,
          otherInfo: { newPassword: faker.internet.password({ length: 20 }) },
        }

        reactiveLocalStorage.setItem(key, initValue)

        // Act
        reactiveLocalStorage.setItem(key, expected)

        // Assert
        const result = reactiveLocalStorage.getItem(key)
        const valueReturnedFromLocalStorage = localStorage.getItem(key)
        const unserializedValue = defaultSerializer.parse(
          valueReturnedFromLocalStorage,
        )

        expect(result).toEqual(expected)
        expect(result).toEqual(unserializedValue)
      })
    })
    describe('(method) getItem', () => {
      it('Should return null when the key not exists into reactiveLocalStorage nor into localStorage', () => {
        // Arrange
        const key = faker.string.sample(17)

        // Act
        const result = reactiveLocalStorage.getItem(key)

        // Assert
        expect(result).toBeNull()
      })
      describe('when the key exists in reactiveLocalStorage', () => {
        it('Should return an object (simple object)', () => {
          // Arrange
          const key = 'simpleObject'
          const expected = {
            user: faker.internet.userName(),
            password: faker.internet.password({ length: 17 }),
          }

          reactiveLocalStorage.setItem(key, expected)

          // Act
          const result = reactiveLocalStorage.getItem(key)

          // Assert
          expect(result).toEqual(expected)
        })
      })
      describe('when the key not exists in reactiveLocalStorage, but exists into localStorage', () => {
        it('Should return an object (nested object)', () => {
          // Arrange
          const defaultSerializer = getDefaultSerializer()
          const key = faker.string.numeric()
          const expected = {
            nestedObject: {
              nestedObject: {
                key1: faker.string.hexadecimal(),
                key2: faker.number.int(),
              },
            },
          }

          const serializedData = defaultSerializer.serialize(expected)
          localStorage.setItem(key, serializedData)

          // Act
          const result = reactiveLocalStorage.getItem(key)

          // Assert
          expect(result).toEqual(expected)
        })
      })
    })
    describe('(method) removeItem', () => {
      it('Should call this method inclusive if not exists the key into reactiveLocalStorage', () => {
        // Arrange
        const key = faker.string.symbol()

        // Act
        const result = () => reactiveLocalStorage.removeItem(key)

        // Assert
        expect(result).not.toThrow()
      })
      it('Should remove an object (nested object)', () => {
        // Arrange
        const key = faker.string.sample()
        const value = {
          key: faker.string.sample(79),
          nestedObject: {
            key: faker.number.int(),
            nestedObject: {
              key: faker.string.sample(),
            },
          },
        }

        reactiveLocalStorage.setItem(key, value)

        // Act
        reactiveLocalStorage.removeItem(key)

        // Assert
        const result = reactiveLocalStorage.getItem(key)

        expect(result).toBeNull()
      })
    })
    describe('(method) clear', () => {
      it('Should remove all element into ReactiveLocalStorage', () => {
        // Arrange
        const expected = 0
        const nElements = faker.number.int({
          max: 100,
        })
        const data = createArrayTestWithObjects(nElements)
        addItemsInReactiveLocalStorage(data, reactiveLocalStorage)

        // Act
        reactiveLocalStorage.clear()

        // Assert
        const result = reactiveLocalStorage.length
        const localStorageLength = localStorage.length

        expect(result).toBe(expected)
        expect(localStorageLength).toBe(expected)
      })
    })
    describe('(method) loadDataFromLocalStorage', () => {
      it('Should load data from localStorage', () => {
        // Arrange
        const defaultSerializer = getDefaultSerializer()
        const input = [
          { key: faker.string.sample(), value: faker.animal.bear() },
          { key: faker.string.sample(), value: faker.commerce.department() },
          {
            key: faker.string.sample(),
            value: faker.company.buzzPhrase(),
          },
        ]

        for (const { key, value } of input) {
          const serializedData = defaultSerializer.serialize(value)
          localStorage.setItem(key, serializedData)
        }

        // Act
        reactiveLocalStorage.loadDataFromLocalStorage()

        // Assert
        for (const { key, value } of input) {
          const expected = value
          const result = reactiveLocalStorage.getItem(key)

          expect(result).toBe(expected)
        }
      })
    })
    describe('(method) removeItemFromEvent', () => {
      it('Should call this method inclusive if not exists the key into reactiveLocalStorage', () => {
        // Arrange
        const key = faker.string.sample(35)

        // Act
        const result = () => reactiveLocalStorage.removeItemFromEvent(key)

        // Assert
        expect(result).not.toThrow()
      })
      it('Should remove an object (Array)', () => {
        // Arrange
        const key = faker.string.sample(77)
        const value = [1, 2, 3, 4, 5]

        reactiveLocalStorage.setItem(key, value)
        localStorage.removeItem(key)

        // Act
        reactiveLocalStorage.removeItemFromEvent(key)

        // Assert
        const result = reactiveLocalStorage.getItem()

        expect(result).toBeNull()
      })
    })
    describe('(method) setItemFromEvent', () => {
      it('Should add an object (Array)', () => {
        // Arrange
        const key = faker.string.sample(79)
        const expected = [
          { key: faker.string.sample(100), value: faker.number.int() },
        ]

        // Act
        reactiveLocalStorage.setItemFromEvent(key, expected)

        // Assert
        const result = reactiveLocalStorage.getItem(key)

        expect(result).toEqual(expected)
      })
      it('Should override an object saved in reactiveLocalStorage when add a new object using the same key', () => {
        // Arrange
        const key = 'simpleObject'
        const initValue = {
          user: faker.internet.userName(),
          password: faker.internet.password({ length: 50 }),
        }
        const expected = [7]

        reactiveLocalStorage.setItem(key, initValue)

        // Act
        reactiveLocalStorage.setItemFromEvent(key, expected)

        // Assert
        const result = reactiveLocalStorage.getItem(key)

        expect(result).toEqual(expected)
      })
    })
  })
  describe('test an instance generated by constructor with parameters (vue Reactive, Storage)', () => {
    let reactiveLocalStorage

    beforeEach(() => {
      const reactiveStorage = reactive({})
      const defaultSerializer = getDefaultSerializer()
      reactiveLocalStorage = getReactiveLocalStorageInstance(
        reactiveStorage,
        localStorage,
        defaultSerializer,
      )
    })

    describe('(getter) length', () => {
      it('Should return 0 when reactiveLocalStorage is empty', () => {
        // Arrange
        const expected = 0

        // Act
        const result = reactiveLocalStorage.length
        const localStorageLength = localStorage.length

        // Assert
        expect(result).toBe(expected)
        expect(localStorageLength).toBe(expected)
      })
      it('Should return 7 when reactiveLocalStorage contain 7 elements', () => {
        // Arrange
        const expected = 7
        const data = createArrayTestWithObjects(expected)
        addItemsInReactiveLocalStorage(data, reactiveLocalStorage)

        // Act
        const result = reactiveLocalStorage.length
        const localStorageLength = localStorage.length

        // Assert
        expect(result).toBe(expected)
        expect(localStorageLength).toBe(expected)
      })
    })
    describe('(getter) reactiveStorage', () => {
      it('Should return the vue reactive instance used', () => {
        // Arrange
        const expected = true

        // Act
        const result = isReactive(reactiveLocalStorage.reactiveStorage)

        // Assert
        expect(result).toBe(expected)
      })
    })
    describe('(method) key', () => {
      it('return null when the key not exists into reactiveLocalStorage', () => {
        // Arrange
        const index = 7

        // Act
        const result = reactiveLocalStorage.key(index)

        // Assert
        expect(result).toBeNull()
      })
      it('return the key in fifth position into reactiveLocalStorage', () => {
        // Arrange
        const index = 4
        const nData = faker.number.int({ min: 10, max: 100 })
        const data = createArrayTestWithObjects(nData)
        const expected = data[index].key
        addItemsInReactiveLocalStorage(data, reactiveLocalStorage)

        // Act
        const result = reactiveLocalStorage.key(index)

        // Assert
        expect(result).toBe(expected)
      })
    })
    describe('(method) setItem', () => {
      it('Should add an object (Array)', () => {
        // Arrange
        const defaultSerializer = getDefaultSerializer()
        const key = faker.string.sample(35)
        const expected = [1, 2, 3, 4, 5, 6, 7]

        // Act
        reactiveLocalStorage.setItem(key, expected)

        // Assert
        const result = reactiveLocalStorage.getItem(key)
        const valueReturnedFromLocalStorage = localStorage.getItem(key)
        const unserializedValue = defaultSerializer.parse(
          valueReturnedFromLocalStorage,
        )

        expect(result).toEqual(expected)
        expect(result).toEqual(unserializedValue)
      })
      it('Should override an object saved in reactiveLocalStorage when add a new object using the same key', () => {
        // Arrange
        const defaultSerializer = getDefaultSerializer()
        const key = faker.string.sample(45)
        const initValue = [1, 2, 3, 4, 5]
        const expected = [1, 2, 3]

        reactiveLocalStorage.setItem(key, initValue)

        // Act
        reactiveLocalStorage.setItem(key, expected)

        // Assert
        const result = reactiveLocalStorage.getItem(key)
        const valueReturnedFromLocalStorage = localStorage.getItem(key)
        const unserializedValue = defaultSerializer.parse(
          valueReturnedFromLocalStorage,
        )

        expect(result).toEqual(expected)
        expect(result).toEqual(unserializedValue)
      })
    })
    describe('(method) getItem', () => {
      it('Should return null when the key not exists into reactiveLocalStorage nor into localStorage', () => {
        // Arrange
        const key = faker.string.sample(50)

        // Act
        const result = reactiveLocalStorage.getItem(key)

        // Assert
        expect(result).toBeNull()
      })
      describe('when the key exists in reactiveLocalStorage', () => {
        it('Should return an object (Array)', () => {
          // Arrange
          const key = faker.string.sample(57)
          const expected = [1, 2, 3, 4, 5, 6, 7]

          reactiveLocalStorage.setItem(key, expected)

          // Act
          const result = reactiveLocalStorage.getItem(key)

          // Assert
          expect(result).toEqual(expected)
        })
      })
      describe('when the key not exists in reactiveLocalStorage, but exists into localStorage', () => {
        it('Should return an object (simple object)', () => {
          // Arrange
          const defaultSerializer = getDefaultSerializer()
          const key = faker.string.sample(57)
          const expected = {
            int: faker.number.int(),
            string: faker.string.sample(),
            username: faker.internet.userName(),
            password: faker.internet.password({ length: 17 }),
            number: {
              typeof: 'number',
              value: faker.number.int(),
            },
          }

          const serializedData = defaultSerializer.serialize(expected)
          localStorage.setItem(key, serializedData)

          // Act
          const result = reactiveLocalStorage.getItem(key)

          // Assert
          expect(result).toEqual(expected)
        })
      })
    })
    describe('(method) removeItem', () => {
      it('Should call this method inclusive if not exists the key into reactiveLocalStorage', () => {
        // Arrange
        const key = faker.string.sample(70)

        // Act
        const result = () => reactiveLocalStorage.removeItem(key)

        // Assert
        expect(result).not.toThrow()
      })
      it('Should remove an object (nested object)', () => {
        // Arrange
        const key = faker.string.sample()
        const value = {
          key: faker.string.sample(79),
          nestedObject: {
            key: faker.number.int(),
            nestedObject: {
              key: faker.string.sample(),
            },
          },
        }

        reactiveLocalStorage.setItem(key, value)

        // Act
        reactiveLocalStorage.removeItem(key)

        // Assert
        const result = reactiveLocalStorage.getItem(key)

        expect(result).toBeNull()
      })
    })
    describe('(method) clear', () => {
      it('Should remove all element into ReactiveLocalStorage', () => {
        // Arrange
        const expected = 0
        const nElements = faker.number.int({ max: 100 })
        const data = createArrayTestWithObjects(nElements)
        addItemsInReactiveLocalStorage(data, reactiveLocalStorage)

        // Act
        reactiveLocalStorage.clear()

        // Assert
        const result = reactiveLocalStorage.length
        const localStorageLength = localStorage.length

        expect(result).toBe(expected)
        expect(localStorageLength).toBe(expected)
      })
    })
    describe('(method) loadDataFromLocalStorage', () => {
      it('Should load data from localStorage', () => {
        // Arrange
        const defaultSerializer = getDefaultSerializer()
        const input = [
          { key: faker.string.sample(), value: faker.animal.bear() },
          { key: faker.string.sample(), value: faker.commerce.department() },
          {
            key: faker.string.sample(),
            value: [1, 2, 7, 5, 7, 1, 2, 3, 4, 5, 1, 2],
          },
        ]

        for (const { key, value } of input) {
          const serializedData = defaultSerializer.serialize(value)
          localStorage.setItem(key, serializedData)
        }

        // Act
        reactiveLocalStorage.loadDataFromLocalStorage()

        // Assert
        for (const { key, value } of input) {
          const expected = value
          const result = reactiveLocalStorage.getItem(key)

          expect(result).toStrictEqual(expected)
        }
      })
    })
    describe('(method) removeItemFromEvent', () => {
      it('Should call this method inclusive if not exists the key into reactiveLocalStorage', () => {
        // Arrange
        const key = faker.string.sample()

        // Act
        const result = () => reactiveLocalStorage.removeItemFromEvent(key)

        // Assert
        expect(result).not.toThrow()
      })
      it('Should remove an object (simple object)', () => {
        // Arrange
        const key = faker.string.sample()
        const value = {
          key: faker.string.sample(),
          int: faker.number.int(),
        }

        reactiveLocalStorage.setItem(key, value)
        localStorage.removeItem(key)

        // Act
        reactiveLocalStorage.removeItemFromEvent(key)

        // Assert
        const result = reactiveLocalStorage.getItem(key)

        expect(result).toBeNull()
      })
    })
    describe('(method) setItemFromEvent', () => {
      it('Should add an object (simple object)', () => {
        // Arrange
        const key = faker.string.sample()
        const expected = {
          value: [1, 2, 3, 4, 5, 6, 7],
        }

        // Act
        reactiveLocalStorage.setItemFromEvent(key, expected)

        // Assert
        const result = reactiveLocalStorage.getItem(key)

        expect(result).toEqual(expected)
      })
      it('Should override an object saved in reactiveLocalStorage when add a new object using the same key', () => {
        // Arrange
        const key = faker.string.sample(17)
        const initValue = {
          value: [1, 2, 3, 4, 5, 6, 7],
        }
        const expected = { ...initValue, secondValue: faker.string.sample() }

        reactiveLocalStorage.setItem(key, initValue)

        // Act
        reactiveLocalStorage.setItemFromEvent(key, expected)

        // Assert
        const result = reactiveLocalStorage.getItem(key)

        expect(result).toEqual(expected)
      })
    })
  })
})
